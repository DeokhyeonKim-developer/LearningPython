네, 그럼 각 문제에 대한 파이썬 정답 코드를 정리해 드리겠습니다.

모든 문제의 기반이 되는 1번 문제의 `find_combinations` 함수를 재귀적으로 구현하고, 2번과 3번 문제는 이 함수를 활용하여 해결합니다.

-----

### 1\. nC\_k 조합 구하기

**목표:** 주어진 리스트 `arr`에서 `k`개의 원소를 뽑는 모든 조합을 반환합니다.

**핵심 로직:**
재귀를 사용하여 "현재 원소를 뽑는 경우"와 "현재 원소를 뽑지 않는 경우"로 나누어 문제를 해결합니다.

1.  **Base Case 1:** `k == 0` (뽑아야 할 개수가 0개) -\> 빈 리스트 `[[]]`를 반환합니다.
2.  **Base Case 2:** `arr`가 비어있거나 `k`가 `arr`의 길이보다 큼 -\> 불가능하므로 `[]`를 반환합니다.
3.  **Recursive Step:**
      * `first = arr[0]` (첫 번째 원소)
      * `rest = arr[1:]` (나머지 리스트)
      * **`first`를 포함하는 조합:** `rest`에서 `k-1`개를 뽑는 조합을 모두 구한 뒤, 각각에 `first`를 추가합니다.
      * **`first`를 포함하지 않는 조합:** `rest`에서 `k`개를 뽑는 조합을 구합니다.
      * 위 두 결과를 합쳐서 반환합니다.

**코드:**

```python
def find_combinations(arr, k):
    """
    주어진 리스트 arr에서 k개의 원소를 뽑는 모든 조합을 반환합니다.
    (itertools 없이 재귀로 직접 구현)
    """
    results = []

    # Base Case 1: 뽑아야 할 개수가 0이면, 빈 조합 [[]] 하나를 반환
    if k == 0:
        return [[]]

    # Base Case 2: 더 이상 뽑을 원소가 없거나, 뽑아야 할 개수가 남은 원소 수보다 많으면 불가능
    if not arr or k > len(arr):
        return []

    # Recursive Step
    first = arr[0]
    rest = arr[1:]

    # Case 1: 'first'를 포함하는 조합
    # (rest 리스트에서 k-1 개를 뽑는 조합을 찾음)
    combinations_with_first = find_combinations(rest, k - 1)
    for combo in combinations_with_first:
        results.append([first] + combo)

    # Case 2: 'first'를 포함하지 않는 조합
    # (rest 리스트에서 k 개를 뽑는 조합을 찾음)
    combinations_without_first = find_combinations(rest, k)
    results.extend(combinations_without_first)

    return results

# --- 실행 ---
arr = [1, 2, 3, 4]
k = 2
print(f"입력: arr={arr}, k={k}")
print("출력:", find_combinations(arr, k))
```

**실행 결과:**

```
입력: arr=[1, 2, 3, 4], k=2
출력: [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
```